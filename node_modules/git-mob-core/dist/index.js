"use strict";var lt=Object.create;var d=Object.defineProperty;var dt=Object.getOwnPropertyDescriptor;var At=Object.getOwnPropertyNames;var wt=Object.getPrototypeOf,yt=Object.prototype.hasOwnProperty;var Ct=(t,r)=>{for(var o in r)d(t,o,{get:r[o],enumerable:!0})},k=(t,r,o,e)=>{if(r&&typeof r=="object"||typeof r=="function")for(let i of At(r))!yt.call(t,i)&&i!==o&&d(t,i,{get:()=>r[i],enumerable:!(e=dt(r,i))||e.enumerable});return t};var A=(t,r,o)=>(o=t!=null?lt(wt(t)):{},k(r||!t||!t.__esModule?d(o,"default",{value:t,enumerable:!0}):o,t)),xt=t=>k(d({},"__esModule",{value:!0}),t);var kt={};Ct(kt,{Author:()=>a,createCoAuthorsFile:()=>st,fetchGitHubAuthors:()=>M,getAllAuthors:()=>gt,getConfig:()=>x,getPrimaryAuthor:()=>Rt,getSelectedCoAuthors:()=>$t,gitConfig:()=>Mt,gitMobConfig:()=>Ft,gitRevParse:()=>Nt,messageFormatter:()=>y,pathToCoAuthors:()=>G,repoAuthorList:()=>ut,saveNewCoAuthors:()=>it,searchGitHubAuthors:()=>mt,setCoAuthors:()=>Ut,setPrimaryAuthor:()=>Lt,solo:()=>pt,updateConfig:()=>_,updateGitTemplate:()=>N});module.exports=xt(kt);var w=require("node:os");function y(t,r){let o="Co-authored-by:",e=new RegExp(`(\r
|\r|
){0,2}(${o}).*`,"g"),i=t.replaceAll(e,"");if(r&&r.length>0){let n=r.map(s=>s.format()).join(w.EOL);return[i,w.EOL,w.EOL,n].join("")}return i}var a=class{constructor(r,o,e,i="Co-authored-by:"){this.key=r,this.name=o,this.email=e,this.trailer=i}format(){return`${this.trailer} ${this.toString()}`}toString(){return`${this.name} <${this.email}>`}};var C=class extends Error{constructor(r){super(`Author with initials "${r}" not found!`)}};var b=A(require("node:fs")),J=A(require("node:os")),H=A(require("node:path")),U=require("node:util");var B=require("node:child_process"),j=require("node:util");var O={processCwd:void 0};function x(t){return O[t]}function _(t,r){if(t in O)O[t]=r;else throw new Error(`Invalid Git Mob Core config property "${t}"`)}async function c(t){let r={encoding:"utf8"},o=x("processCwd");o&&(r.cwd=o);let e=(0,j.promisify)(B.exec),{stderr:i,stdout:n}=await e(t,r);if(i)throw new Error(`Git mob core execCommand: "${t}" ${i.trim()}`);return n.trim()}async function u(t){try{return await c(`git config --get ${t}`)}catch{return}}async function I(t){try{return await c(`git config --get-all ${t}`)}catch{return}}async function l(t,r){try{await c(`git config ${t} "${r}"`)}catch{let o=`Option ${t} has multiple values. Cannot overwrite multiple values for option ${t} with a single value.`;throw new Error(`Git mob core setConfig: ${o}`)}}async function q(t){let r="git shortlog -seni HEAD";return t&&(r+=` --author="${t}"`),c(r)}async function h(){return c("git rev-parse --show-toplevel")}async function D(){try{return await c("git rev-parse --is-inside-work-tree")==="true"}catch{return!1}}function g(t,r){return{read:async o=>{let i=await(t||(0,U.promisify)(b.default.readFile))(o||await G());return JSON.parse(i)},overwrite:async(o,e)=>(r||(0,U.promisify)(b.default.writeFile))(e||await G(),JSON.stringify(o,null,2)),toList(o){return Object.entries(o.coauthors).map(([i,{name:n,email:s}])=>new a(i,n,s))},toObject(o){let e={coauthors:{}};for(let i of o)e.coauthors[i.key]={name:i.name,email:i.email};return e}}}var v=".git-coauthors";function $(){return process.env.GITMOB_COAUTHORS_PATH?process.env.GITMOB_COAUTHORS_PATH:H.default.join(J.default.homedir(),v)}async function G(){if(process.env.GITMOB_COAUTHORS_PATH)return process.env.GITMOB_COAUTHORS_PATH;let t=null;try{t=H.default.join(await h(),v)}catch{t=""}return b.default.existsSync(t)?t:$()}var T=require("node:fs/promises");function bt(t){return t.code!=="ENOENT"}async function Gt(t,r){let o=await Q(t),e=y(o||"",r);await(0,T.writeFile)(t,e)}async function Q(t){try{return await(0,T.readFile)(t,{encoding:"utf8"})}catch(r){if(r&&bt(r))throw r}}function S(t,r,o){let e=r||Gt,i=o||Q;return{writeCoAuthors:async n=>{await e(t,n)},readCoAuthors:async()=>i(t),removeCoAuthors:async()=>e(t,[])}}async function W(){return await u("--local git-mob-config.use-local-template")==="true"}async function K(){return await u("--global git-mob-config.github-fetch")==="true"}async function R(){return I("--global git-mob.co-author")}async function V(t){let r=`git config --add --global git-mob.co-author "${t}"`;return c(r)}async function z(){try{return await c("git config --global --remove-section git-mob")}catch{}}var p=require("node:path"),X=require("node:os");async function Y(){await u("commit.template")||await l("--global commit.template",Z())}async function E(t){return process.env.GITMOB_MESSAGE_PATH?(0,p.resolve)(process.env.GITMOB_MESSAGE_PATH):t?(0,p.resolve)(await h(),t):(0,p.resolve)(Z())}function Z(){return(0,p.join)((0,X.homedir)(),".gitmessage")}async function L(){return u("--local commit.template")}async function P(){return await u("--global commit.template")||E()}async function tt(){return u("user.name")}async function rt(){return u("user.email")}async function ot(t){return l("user.name",t)}async function et(t){return l("user.email",t)}async function it(t){if(!Array.isArray(t))throw new TypeError("saveNewCoAuthors argument should be an Array of Authors");let r=g(),o=await r.read(),e=[];for(let i of t){let{key:n,name:s,email:m}=i;if(n in o.coauthors)throw new Error(`Duplicate key ${n} exists in .git-coauthors`);o.coauthors[n]={name:s,email:m},e.push(new a(n,s,m))}return await r.overwrite(o),e}var nt=require("node:fs");var vt={coauthors:{pa:{name:"Placeholder Author",email:"placeholder@author.org"}}};async function st(t){let r=g(),o=$();if((0,nt.existsSync)(o))throw new Error(`${v} file exists globally`);if(t&&t.length>0){let e=r.toObject(t);await r.overwrite(e,o)}else await r.overwrite(vt,o);return!0}var at=require("node:os");async function ut(t){let e=(await q(t)).split(at.EOL).map(Tt).filter(i=>i!==void 0);if(e.length>0)return e}function Tt(t){let o=/\d+\t(.+)\s<(.+)>/.exec(t);if(o!==null){let[,e,i]=o;return new a(St(e,i),e,i)}}function St(t,r){let o=t.toLowerCase().split(" ").reduce(function(i,n){return i+n[0]},""),e=r.slice(0,2);return o+e}var ct=A(require("node:https"));async function F(t,r){return new Promise((o,e)=>{ct.default.request(t,r,n=>{let s="";n.on("data",m=>{s+=m}),n.on("end",()=>{o({statusCode:n.statusCode,data:JSON.parse(s)})})}).on("error",n=>{e(n)}).end()})}var Et="https://api.github.com/users",Pt="https://api.github.com/search/users",f={headers:{Accept:"application/vnd.github.v3+json",method:"GET"}};function Ot(t){return"id"in t&&"login"in t&&"name"in t}async function M(t,r,o=F){if(!r)throw new Error("Error no user-agent header string given.");f.headers={...f.headers,"user-agent":r};let e=await Promise.all(t.map(async n=>o(Et+"/"+n,f))),i=[];for(let n of e)if(ht(n.statusCode),Ot(n.data)){let{login:s,id:m,name:ft}=n.data;i.push(new a(s,ft||s,`${m}+${s}@users.noreply.github.com`))}return i}async function mt(t,r,o=F){if(!r)throw new Error("Error no user-agent header string given.");f.headers={...f.headers,"user-agent":r};let e=await o(Pt+"?q="+t,f);ht(e.statusCode);let n=e.data.items.map(s=>s.login);return M(n,r,o)}function ht(t){if(t===404)throw new Error("GitHub user not found!");if(t&&t>299)throw new Error(`Error failed to fetch GitHub user! Status code ${t}.`)}async function gt(){let t=g();return t.toList(await t.read())}async function Ut(t){let r=Ht(t,await gt());await pt();for(let o of r)await V(o.toString());return await N(r),r}async function N(t){let[r,o]=await Promise.all([L(),u("commit.template")]),e=S(await E(o));return t&&t.length>0?(r&&await S(await P()).writeCoAuthors(t),e.writeCoAuthors(t)):(r&&await S(await P()).removeCoAuthors(),e.removeCoAuthors())}function Ht(t,r){let o=[];for(let e of t){let i=r.find(n=>n.key===e);if(!i)throw new C(e);o.push(i)}return o}async function $t(t){let r="",o=await R();return o&&(r=o),t.filter(e=>r.includes("<"+e.email))}async function pt(){return await Y(),await z(),N()}async function Rt(){let t=await tt(),r=await rt();if(t&&r)return new a("prime",t,r)}async function Lt(t){await ot(t.name),await et(t.email)}var Ft={localTemplate:W,fetchFromGitHub:K,getSetCoAuthors:R},Mt={getLocalCommitTemplate:L,getGlobalCommitTemplate:P},Nt={insideWorkTree:D,topLevelDirectory:h};0&&(module.exports={Author,createCoAuthorsFile,fetchGitHubAuthors,getAllAuthors,getConfig,getPrimaryAuthor,getSelectedCoAuthors,gitConfig,gitMobConfig,gitRevParse,messageFormatter,pathToCoAuthors,repoAuthorList,saveNewCoAuthors,searchGitHubAuthors,setCoAuthors,setPrimaryAuthor,solo,updateConfig,updateGitTemplate});
